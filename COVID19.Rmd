---
title: "COVID-19 Data Analysis"
author: "Anon."
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load Packages

Here are some packages that we will need for our analysis.

```{r echo = T, message = F, warning = F}
library(tidyverse)
library(RColorBrewer)
library(plotly)
```

## Import Data

Now, let's import our data. This data set is taken from the Johns Hopkins Github site, as found in the URL below. It contains COVID-19 data, including number of cases and deaths, for both states in the U.S. and countries around the world. It organizes these cases and deaths by date.

```{r echo = T, message = F, warning = F}
url_in <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/"
file_names <- c("time_series_covid19_confirmed_US.csv",  "time_series_covid19_confirmed_global.csv", "time_series_covid19_deaths_US.csv",  "time_series_covid19_deaths_global.csv")
urls <- str_c(url_in,file_names)
urls
global_cases <- read_csv(urls[2])
global_deaths <- read_csv(urls[4])
US_cases <- read_csv(urls[1])
US_deaths <- read_csv(urls[3])
```

## Tidy Data

Let's make our data more manageable to work with.

```{r echo = T, message = F, warning = F}
# Make "date" and "cases" separate columns

global_cases <- global_cases %>%
  pivot_longer(cols= -c(`Province/State`,
                        `Country/Region`, Lat, Long),
               names_to = "date",
               values_to = "cases") %>%
  select(-c(Lat,Long))

global_deaths <- global_deaths %>%
  pivot_longer(cols = -c(`Province/State`,
                         `Country/Region`, Lat, Long),
               names_to = "date",
               values_to = "deaths") %>%
  select(-c(Lat,Long))

# Join global_cases with global_deaths to create one global data set
# Rename columns to something easier to work with
# Make the "date" variable date type

global <- global_cases %>%
  full_join(global_deaths) %>%
  rename(Country_Region = `Country/Region`,
         Province_State = `Province/State`) %>%
  mutate(date = mdy(date))

# Filter data to include only cases that exist

global <- global %>%
  filter(cases > 0)

# Do the same for US data

US_cases <- US_cases %>%
  pivot_longer(cols = -c(UID:Combined_Key),
               names_to = "date",
               values_to = "cases") %>%
  select(Admin2:cases) %>%
  mutate(date = mdy(date)) %>%
  select(-c(Lat,Long_))

US_deaths <- US_deaths %>%
  pivot_longer(cols = -c(UID:Population),
               names_to = "date",
               values_to = "deaths") %>%
  select(Admin2:deaths) %>%
  mutate(date = mdy(date)) %>%
  select(-c(Lat, Long_))

US <- US_cases %>%
  full_join(US_deaths)

# Create new variables for global data that match US data

global <- global %>%
  unite("Combined_Key",
        c(Province_State, Country_Region),
        sep = ", ",
        na.rm = TRUE,
        remove = FALSE)

# Find population data for global, read it in and join it

uid_lookup_url <- "https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/UID_ISO_FIPS_LookUp_Table.csv"

uid <- read_csv(uid_lookup_url) %>%
  select(-c(Lat, Long_, Combined_Key, code3, iso2, iso3, Admin2))

global <- global %>%
  left_join(uid, by = c("Province_State", "Country_Region")) %>%
  select(-c(UID, FIPS)) %>%
  select(Province_State, Country_Region, date,
         cases, deaths, Population, Combined_Key)

# Add deaths_per_mil variable to global using population data

global <- global %>% 
  mutate(deaths_per_mill = deaths *1000000 / Population)

# Group US data by state

US_by_state <- US %>%
  group_by(Province_State, Country_Region, date) %>%
  summarize(cases = sum(cases), deaths = sum(deaths),
            Population = sum(Population)) %>%
  mutate(deaths_per_mill = deaths *1000000 / Population) %>%
  select(Province_State, Country_Region, date,
         cases, deaths, deaths_per_mill, Population) %>%
  ungroup()
 
# Group US state data into a US total

US_totals <- US_by_state %>%
  group_by(Country_Region, date) %>%
  summarize(cases = sum(cases), deaths = sum(deaths),
            Population = sum(Population)) %>%
  mutate(deaths_per_mill = deaths *1000000 / Population) %>%
  select(Country_Region, date, cases, deaths, deaths_per_mill, Population) %>%
  ungroup()

# Add variables to see how many new cases and deaths there are each day

US_by_state <- US_by_state %>%
  mutate(new_cases = cases - lag(cases),
         new_deaths = deaths - lag(deaths))
US_totals <- US_totals %>%
  mutate(new_cases = cases - lag(cases),
         new_deaths = deaths - lag(deaths))
```

### Summary of Data

Now that our data is ready to use, let's take a quick look at our data sets.

```{r echo = T, message = F, warning = F}
head(global)
head(US_by_state)
head(US_totals)
```

### Statement of Intention

My goal in working with this data is to identify any patterns that exist with respect to the number of deaths. I will see if number of deaths has any relationship with population, country, or state. I will also create a linear model and use that model to predict hypothetical values.

Let's get started.

## Visualizations and Analysis

Let's see which countries had the most COVID-19 deaths per million people in their population. Here is the top 10:

```{r echo = T, message = F, warning = F}
global %>% 
  select(c(Country_Region, deaths_per_mill)) %>% 
  group_by(Country_Region) %>% 
  summarize(deaths_per_mill = max(deaths_per_mill)) %>% 
  slice_max(deaths_per_mill, n = 10)
```

Here, we can see that **Peru** had the most COVID-19 deaths per million people, followed by other countries mostly located in Eastern Europe.

Let's visualize this relationship.

```{r echo = T, message = F, warning = F}
p1 <- global %>% 
  select(-c(Province_State, date, Combined_Key)) %>% 
  group_by(Country_Region) %>% 
  summarize(cases = max(cases),
            deaths = max(deaths),
            Population = mean(Population),
            deaths_per_mill = max(deaths_per_mill)) %>% 
  slice_max(deaths_per_mill, n = 10) %>% 
  ggplot(aes(x = reorder(Country_Region, -deaths_per_mill),
             y = deaths_per_mill,
             fill = deaths_per_mill)) +
  geom_col(show.legend = F) +
  scale_fill_distiller(palette = "Reds", direction = 1) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "COVID-19 Deaths by Country, Adjusted for Population",
       x = "Country/Region",
       y = "Deaths Per Million People")

# Create an interactive plot with zoom, pan, and tooltip features
ggplotly(p1, dynamicTicks = T) %>% 
  layout(dragmode = "pan") %>%
  config(scrollZoom = T,
         displayModeBar = F)
```

Now, let's do the same for U.S. states.

```{r echo = T, message = F, warning = F}
US_by_state %>% 
  select(c(Province_State, deaths_per_mill)) %>% 
  group_by(Province_State) %>% 
  summarize(deaths_per_mill = max(deaths_per_mill)) %>% 
  slice_max(deaths_per_mill, n = 10)
```

**Arizona** had the most COVID-19 deaths per million people, followed closely by other states located mostly in the Southern U.S.

Here is a visualization of this relationship, this time including all U.S. states and territories.

```{r echo = T, message = F, warning = F}
p2 <- US_by_state %>% 
  select(c(Province_State, cases, deaths, deaths_per_mill,
           Population)) %>% 
  group_by(Province_State) %>% 
  summarize(cases = max(cases),
            deaths = max(deaths),
            deaths_per_mill = max(deaths_per_mill),
            Population = mean(Population)) %>%
  ggplot(aes(x = reorder(Province_State, -deaths_per_mill),
             y = deaths_per_mill,
             fill = deaths_per_mill)) +
  geom_col(show.legend = F) +
  scale_fill_distiller(palette = "Reds", direction = 1) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "COVID-19 Deaths by U.S. State, Adjusted for Population",
       x = "US State",
       y = "Deaths Per Million People")

# Create an interactive plot with zoom, pan, and tooltip features
ggplotly(p2, dynamicTicks = T) %>% 
  layout(dragmode = "pan") %>%
  config(scrollZoom = T,
         displayModeBar = F)
```

## Linear Model

Let's create a model for the total number of deaths as a function of a state's population. I will also include total number of cases as a color variable to make the plot more interesting, although this will not affect the linear model.

### Visualization

```{r echo = T, message = F, warning = F}
p <- US_by_state %>% 
  select(Province_State, cases, deaths, Population) %>% 
  group_by(Province_State) %>% 
  summarize(deaths = max(deaths),
            Population = mean(Population),
            cases = max(cases)) %>% 
  ggplot(aes(label = Province_State,
             x = Population,
             y = deaths)) +
  geom_point(aes(color = cases),
             size = 4) +
  geom_smooth(method = lm, color = "blue", alpha = 0) +
  theme_bw() +
  scale_color_distiller(palette = "Reds", direction = 1) +
  labs(title = "Deaths by Population of U.S. States",
       x = "Population",
       y = "Total Deaths")

# Create an interactive plot with zoom, pan, and tooltip features
ggplotly(p, dynamicTicks = T) %>% 
  layout(dragmode = "pan") %>%
  config(scrollZoom = T,
         displayModeBar = F)
```

### Statistics & Predictions

Let's get more information about this model.

```{r echo = T, message = F, warning = F}
US_by_state %>% 
  select(Province_State, cases, deaths, Population) %>% 
  group_by(Province_State) %>% 
  summarize(deaths = max(deaths),
            Population = mean(Population),
            cases = max(cases)) %>% 
  lm(deaths ~ Population, data = .) %>% 
  summary()
```

The Multiple R-Squared is 0.93, meaning that approximately 93% of the total number of deaths can be explained by the population of that state. That is a very powerful model, as we might have expected.

Let's use this model to predict the total number of deaths in a hypothetical state given certain population values of our choosing.

```{r echo = T, message = F, warning = F}
US_by_state %>% 
  select(Province_State, cases, deaths, Population) %>% 
  group_by(Province_State) %>% 
  summarize(deaths = max(deaths),
            Population = mean(Population),
            cases = max(cases)) %>% 
  lm(deaths ~ Population, data = .) %>% 
  predict(data.frame(Population = c(15000000, 30000000, 60000000))) %>% 
  round()
```

* If a state's population were **15 million**, we would expect about **48,494** total deaths by COVID-19.

* If a state's population were **30 million**, we would expect about **95,656** total deaths by COVID-19.

* If a state's population were **60 million**, we would expect about **189,981** total deaths by COVID-19.

## Bias Identification Statement

There are many potential sources of bias in both the data and my analysis. The data are limited by the accuracy of the information and the reliability of the sources from which that information was obtained. There may be a disconnect between the truth and the data that is based largely on reporting accuracy. For example, we cannot know if one country truly had more cases of COVID-19 than another, or if that country simply had more accurate reporting protocols in place than the other. It is also possible that more data exists for some countries than others simply due to the methods and rigor of testing and reporting cases of COVID-19. While that is something to be aware of, it is something that we simply cannot control at a global scale. The best we can do is work with the data we are given with the understanding that these biases may (and likely do) exist, hoping that our analyses remain useful and maximally valid.

Aside from the data itself, my analysis is biased by my own preconceptions and choices. My biases (including my technical abilities) dictated how the data sets were cleaned, which variables were selected, which analyses were performed, and which visualizations were designed. It is my hope that I allowed for free expression of the data to the extent that that is possible; however, I am aware that it is impossible to completely disconnect the analysis from the analyzer.

## Session Info

```{r echo = T, message = F, warning = F}
sessionInfo()
```

Thank you.